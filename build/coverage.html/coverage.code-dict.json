{"/home/travis/build/npmtest/node-npmtest-jdbc/test.js":"/* istanbul instrument in package npmtest_jdbc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jdbc/lib.npmtest_jdbc.js":"/* istanbul instrument in package npmtest_jdbc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jdbc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jdbc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jdbc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jdbc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jdbc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jdbc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jdbc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jdbc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jdbc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jdbc.__dirname + '/lib.npmtest_jdbc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/index.js":"module.exports = require(\"./lib/jdbc.js\");\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/jdbc.js":"/* jshint node: true */\n\"use strict\";\nvar Pool = require(\"./pool\");\n\nfunction JDBC(config) {\n  Pool.call(this, config);\n}\n\nJDBC.prototype = Object.create(Pool.prototype);\nJDBC.prototype.constructor = JDBC;\n\nmodule.exports = JDBC;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/pool.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar asyncjs = require('async');\nvar uuid = require('uuid');\nvar jinst = require(\"./jinst\");\nvar dm = require('./drivermanager');\nvar Connection = require('./connection');\nvar winston = require('winston');\n\nvar java = jinst.getInstance();\n\nif (!jinst.isJvmCreated()) {\n  jinst.addOption(\"-Xrs\");\n}\n\nvar keepalive = function(conn, query) {\n  var self = this;\n  conn.createStatement(function(err, statement) {\n    if (err) return winston.error(err);\n    statement.execute(query, function(err, result) {\n      if (err) return winston.error(err);\n      winston.silly(\"%s - Keep-Alive\", new Date().toUTCString());\n    });\n  });\n};\n\nvar addConnection = function(url, props, ka, maxIdle, callback) {\n  dm.getConnection(url, props, function(err, conn) {\n    if (err) {\n      return callback(err);\n    } else {\n      var connobj = {\n        uuid: uuid.v4(),\n        conn: new Connection(conn),\n        keepalive: ka.enabled ? setInterval(keepalive, ka.interval, conn, ka.query) : false\n      };\n\n      if (maxIdle) {\n        connobj.lastIdle = new Date().getTime();\n      }\n\n      return callback(null, connobj);\n    }\n  });\n};\n\nvar addConnectionSync = function(url, props, ka, maxIdle) {\n  var conn = dm.getConnectionSync(url, props);\n  var connobj = {\n    uuid: uuid.v4(),\n    conn: new Connection(conn),\n    keepalive: ka.enabled ? setInterval(keepalive, ka.interval, conn, ka.query) : false\n  };\n\n  if (maxIdle) {\n    connobj.lastIdle = new Date().getTime();\n  }\n\n  return connobj;\n};\n\nfunction Pool(config) {\n  this._url = config.url;\n  this._props = (function (config) {\n    var Properties = java.import('java.util.Properties');\n    var properties = new Properties();\n\n    for(var name in config.properties) {\n      properties.putSync(name, config.properties[name]);\n    }\n\n    if (config.user && properties.getPropertySync('user') === undefined) {\n      properties.putSync('user', config.user);\n    }\n\n    if (config.password && properties.getPropertySync('password') === undefined) {\n      properties.putSync('password', config.password);\n    }\n\n    return properties;\n  })(config);\n  this._drivername = config.drivername ? config.drivername : '';\n  this._minpoolsize = config.minpoolsize ? config.minpoolsize : 1;\n  this._maxpoolsize = config.maxpoolsize ? config.maxpoolsize : 1;\n  this._keepalive = config.keepalive ? config.keepalive : {\n    interval: 60000,\n    query: 'select 1',\n    enabled: false\n  };\n  this._maxidle = (!this._keepalive.enabled && config.maxidle) || null;\n  this._logging = config.logging ? config.logging : {\n    level: 'error'\n  };\n  this._pool = [];\n  this._reserved = [];\n}\n\nvar connStatus = function(acc, pool) {\n  _.reduce(pool, function(conns, connobj) {\n    var conn = connobj.conn;\n    var closed = conn.isClosedSync();\n    var readonly = conn.isReadOnlySync();\n    var valid = conn.isValidSync(1000);\n    conns.push({\n      uuid: connobj.uuid,\n      closed: closed,\n      readonly: readonly,\n      valid: valid\n    });\n    return conns;\n  }, acc);\n  return acc;\n};\n\nPool.prototype.status = function(callback) {\n  var self = this;\n  var status = {};\n  status.available = self._pool.length;\n  status.reserved = self._reserved.length;\n  status.pool = connStatus([], self._pool);\n  status.rpool = connStatus([], self._reserved);\n  callback(null, status);\n};\n\n\nPool.prototype.initialize = function(callback) {\n  var self = this;\n\n  winston.level = this._logging.level;\n\n  // If a drivername is supplied, initialize the via the old method,\n  // Class.forName()\n  if (this._drivername) {\n    java.newInstance(this._drivername, function(err, driver) {\n      if (err) {\n        return callback(err);\n      } else {\n        dm.registerDriver(driver, function(err) {\n          if (err) {\n            return callback(err);\n          }\n        });\n      }\n    });\n  }\n\n  asyncjs.times(self._minpoolsize, function(n, next){\n    addConnection(self._url, self._props, self._keepalive, self._maxidle, function(err, conn) {\n      next(err, conn);\n    });\n  }, function(err, conns) {\n    if (err) {\n      return callback(err);\n    } else {\n      _.each(conns, function(conn) {\n        self._pool.push(conn);\n      });\n      return callback(null);\n    }\n  });\n\n  jinst.events.emit('initialized');\n};\n\nPool.prototype.reserve = function(callback) {\n  var self = this;\n  var conn = null;\n  self._closeIdleConnections();\n\n  if (self._pool.length > 0 ) {\n    conn = self._pool.shift();\n\n    if (conn.lastIdle) {\n      conn.lastIdle = new Date().getTime();\n    }\n\n    self._reserved.unshift(conn);\n  } else if (self._reserved.length < self._maxpoolsize) {\n    try {\n      conn = addConnectionSync(self._url, self._props, self._keepalive, self._maxidle);\n      self._reserved.unshift(conn);\n    } catch (err) {\n      winston.error(err);\n      conn = null;\n      return callback(err);\n    }\n  }\n\n  if (conn === null) {\n    callback(new Error(\"No more pool connections available\"));\n  } else {\n    callback(null, conn);\n  }\n};\n\nPool.prototype._closeIdleConnections = function() {\n  if (! this._maxidle) {\n    return;\n  }\n\n  var self = this;\n\n  closeIdleConnectionsInArray(self._pool, this._maxidle);\n  closeIdleConnectionsInArray(self._reserved, this._maxidle);\n};\n\nfunction closeIdleConnectionsInArray(array, maxIdle) {\n  var time = new Date().getTime();\n  var maxLastIdle = time - maxIdle;\n\n  for (var i = array.length - 1; i >=0; i--) {\n    var conn = array[i];\n    if (typeof conn === 'object' && conn.conn !== null) {\n      if (conn.lastIdle < maxLastIdle) {\n        console.log(\"closing connection because it has been idle for \" + (time - conn.lastIdle) + \"ms\");\n        conn.conn.close(function(err) { });\n        array.splice(i, 1);\n      }\n    }\n  }\n}\n\nPool.prototype.release = function(conn, callback) {\n  var self = this;\n  if (typeof conn === 'object') {\n    var uuid = conn.uuid;\n    self._reserved = _.reject(self._reserved, function(conn) {\n      return conn.uuid === uuid;\n    });\n\n    if (conn.lastIdle) {\n      conn.lastIdle = new Date().getTime();\n    }\n\n    self._pool.unshift(conn);\n    return callback(null);\n  } else {\n    return callback(new Error(\"INVALID CONNECTION\"));\n  }\n};\n\nPool.prototype.purge = function(callback) {\n  var self = this;\n  var conns = self._pool.concat(self._reserved);\n\n  asyncjs.each(conns,\n    function(conn, done) {\n      if (typeof conn === 'object' && conn.conn !== null) {\n        conn.conn.close(function(err) {\n          //we don't want to prevent other connections from being closed\n          done();\n        });\n      } else {\n        done();\n      }\n    },\n    function() {\n      self._pool = [];\n      self._reserved = [];\n\n      callback();\n    }\n  );\n};\n\nmodule.exports = Pool;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/jinst.js":"/* jshint node: true */\n\"use strict\";\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar java = require('java');\nvar winston = require('winston');\n\nfunction isJvmCreated() {\n  return typeof java.onJvmCreated !== 'function';\n}\n\nvar jinst = module.exports = {\n  isJvmCreated: function() {\n    return isJvmCreated();\n  },\n  addOption: function(option) {\n    if (!isJvmCreated() && option) {\n      java.options.push(option);\n    } else if (isJvmCreated()) {\n      winston.error(\"You've tried to add an option to an already running JVM!\");\n      winston.error(\"This isn't currently supported.  Please add all option entries before calling any java methods\");\n      winston.error(\"You can test for a running JVM with the isJvmCreated funtion.\");\n    }\n  },\n  setupClasspath: function(dependencyArr) {\n    if (!isJvmCreated() && dependencyArr) {\n      java.classpath.push.apply(java.classpath, dependencyArr);\n    } else if (isJvmCreated()) {\n      winston.error(\"You've tried to add an entry to the classpath of an already running JVM!\");\n      winston.error(\"This isn't currently supported.  Please add all classpath entries before calling any java methods\");\n      winston.error(\"You can test for a running JVM with the isJvmCreated funtion.\");\n    }\n  },\n  getInstance: function() {\n    return java;\n  },\n  events: new EventEmitter(),\n};\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/drivermanager.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar jinst = require(\"./jinst.js\");\nvar java = jinst.getInstance();\n\nvar DM = 'java.sql.DriverManager';\n\nmodule.exports = {\n  getConnection: function(url, propsoruser, password, callback) {\n    // Get arguments as an array\n    var args = Array.prototype.slice.call(arguments);\n\n    // Pull the callback off the end of the arguments\n    callback = args.pop();\n\n    // Check arguments for validity, and return error if invalid\n    var validArgs = args[0] && (\n      // args[1] (propsoruser) and args[2] (password) can both be falsey\n      ! (args[1] || args[2]) ||\n\n      // args[1] (propsoruser) and args[2] (password) can both be strings\n      (_.isString(args[1]) && _.isString(args[2])) ||\n\n      // args[1] (propsoruser) can be an object if args[2] (password) is falsey\n      (_.isObject(args[1]) && ! args[2])\n    );\n\n    if(! validArgs) {\n      return callback(new Error(\"INVALID ARGUMENTS\"));\n    }\n\n    // Push a callback handler onto the arguments\n    args.push(function(err, conn) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, conn);\n      }\n    });\n\n    // Add DM and 'getConnection' string onto beginning of args\n    // (unshift in reverse order of desired order)\n    args.unshift('getConnection');\n    args.unshift(DM);\n\n    // Forward modified arguments to java.callStaticMethod\n    java.callStaticMethod.apply(java, args);\n  },\n  getConnectionSync: function(url, propsoruser, password) {\n    // Get arguments as an array\n    var args = Array.prototype.slice.call(arguments);\n\n    // Check arguments for validity, and return error if invalid\n    var validArgs = args[0] && (\n      // args[1] (propsoruser) and args[2] (password) can both be falsey\n      ! (args[1] || args[2]) ||\n\n      // args[1] (propsoruser) and args[2] (password) can both be strings\n      (_.isString(args[1]) && _.isString(args[2])) ||\n\n      // args[1] (propsoruser) can be an object if args[2] (password) is falsey\n      (_.isObject(args[1]) && ! args[2])\n    );\n\n    if(! validArgs) {\n      return new Error(\"INVALID ARGUMENTS\");\n    }\n\n    // Add DM and 'getConnection' string onto beginning of args\n    // (unshift in reverse order of desired order)\n    args.unshift('getConnection');\n    args.unshift(DM);\n\n    // Forward modified arguments to java.callStaticMethod\n    return java.callStaticMethodSync.apply(java, args);\n  },\n  getLoginTimeout: function(callback) {\n    java.callStaticMethod(DM, 'getLoginTimeout', function(err, seconds) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, seconds);\n      }\n    });\n  },\n  registerDriver: function(driver, callback) {\n    java.callStaticMethod(DM, 'registerDriver', driver, function(err) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null);\n      }\n    });\n  },\n  setLoginTimeout: function(seconds, callback) {\n    java.callStaticMethod(DM, 'setLoginTimeout', seconds, function(err) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, true);\n      }\n    });\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/connection.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require(\"lodash\");\nvar jinst = require(\"./jinst\");\nvar CallableStatement = require('./callablestatement');\nvar PreparedStatement = require('./preparedstatement');\nvar DatabaseMetaData = require('./databasemetadata');\nvar Statement = require('./statement');\nvar SQLWarning = require('./sqlwarning');\nvar java = jinst.getInstance();\n\nif (!jinst.isJvmCreated()) {\n  jinst.addOption(\"-Xrs\");\n}\n\nfunction Connection(conn) {\n  this._conn = conn;\n  this._txniso = (function() {\n    var txniso = [];\n\n    txniso[java.getStaticFieldValue(\"java.sql.Connection\", \"TRANSACTION_NONE\")] = \"TRANSACTION_NONE\";\n    txniso[java.getStaticFieldValue(\"java.sql.Connection\", \"TRANSACTION_READ_COMMITTED\")] = \"TRANSACTION_READ_COMMITTED\";\n    txniso[java.getStaticFieldValue(\"java.sql.Connection\", \"TRANSACTION_READ_UNCOMMITTED\")] = \"TRANSACTION_READ_UNCOMMITTED\";\n    txniso[java.getStaticFieldValue(\"java.sql.Connection\", \"TRANSACTION_REPEATABLE_READ\")] = \"TRANSACTION_REPEATABLE_READ\";\n    txniso[java.getStaticFieldValue(\"java.sql.Connection\", \"TRANSACTION_SERIALIZABLE\")] = \"TRANSACTION_SERIALIZABLE\";\n\n    return txniso;\n  })();\n}\n\nConnection.prototype.abort = function(executor, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.clearWarnings = function(callback) {\n  this._conn.clearWarnings(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.close = function(callback) {\n  var self = this;\n\n  if (self._conn === null) {\n    return callback(null);\n  }\n\n  self._conn.close(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      self._conn = null;\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.commit = function(callback) {\n  this._conn.commit(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.createArrayOf = function(typename, objarr, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.createBlob = function(callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.createClob = function(callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.createNClob = function(callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.createSQLXML = function(callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.createStatement = function(arg1, arg2, arg3, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  var invalidArgs = false;\n  _.forEach(args, function(arg) {\n    if (! _.isNumber(arg)) {\n      invalidArgs = true;\n      // Lodash break\n      return false;\n    }\n  });\n\n  if (invalidArgs) {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, statement) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new Statement(statement));\n    }\n  });\n\n  // Forward modified arguments to _conn.createStatement\n  this._conn.createStatement.apply(this._conn, args);\n};\n\nConnection.prototype.createStruct = function(typename, attrarr, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.getAutoCommit = function(callback) {\n  this._conn.getAutoCommit(function(err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, result);\n    }\n  });\n};\n\nConnection.prototype.getCatalog = function(callback) {\n  this._conn.getCatalog(function(err, catalog) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, catalog);\n    }\n  });\n};\n\nConnection.prototype.getClientInfo = function(name, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, result);\n    }\n  });\n\n  // Forward modified arguments to _conn.getClientInfo\n  this._conn.getClientInfo.apply(this._conn, args);\n};\n\nConnection.prototype.getHoldability = function(callback) {\n  this._conn.getClientInfo(function(err, holdability) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, holdability);\n    }\n  });\n};\n\nConnection.prototype.getMetaData = function(callback) {\n  this._conn.getMetaData(function(err, dbm) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new DatabaseMetaData(dbm));\n    }\n  });\n};\n\nConnection.prototype.getNetworkTimeout = function(callback) {\n  this._conn.getNetworkTimeout(function(err, ms) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, ms);\n    }\n  });\n};\n\nConnection.prototype.getSchema = function(callback) {\n  this._conn.getSchema(function(err, schema) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, schema);\n    }\n  });\n};\n\nConnection.prototype.getTransactionIsolation = function(callback) {\n  var self = this;\n\n  self._conn.getTransactionIsolation(function(err, txniso) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, self._txniso[txniso]);\n    }\n  });\n};\n\nConnection.prototype.getTypeMap = function(callback) {\n  this._conn.getTypeMap(function(err, map) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, map);\n    }\n  });\n};\n\nConnection.prototype.getWarnings = function(callback) {\n  this._conn.getWarnings(function(err, sqlwarning) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new SQLWarning(sqlwarning));\n    }\n  });\n};\n\nConnection.prototype.isClosed = function(callback) {\n  this._conn.isClosed(function(err, closed) {\n    if (err) return callback(err);\n    callback(null, closed);\n  });\n};\n\nConnection.prototype.isClosedSync = function() {\n  return this._conn.isClosedSync();\n};\n\nConnection.prototype.isReadOnly = function(callback) {\n  this._conn.isReadOnly(function(err, readonly) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, readonly);\n    }\n  });\n};\n\nConnection.prototype.isReadOnlySync = function() {\n  return this._conn.isReadOnlySync();\n};\n\nConnection.prototype.isValid = function(timeout, callback) {\n  this._conn.isValid(timeout, function(err, valid) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, valid);\n    }\n  });\n};\n\nConnection.prototype.isValidSync = function(timeout) {\n  return this._conn.isValidSync(timeout);\n};\n\nConnection.prototype.nativeSQL = function(sql, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nConnection.prototype.prepareCall = function(sql, rstype, rsconcurrency, rsholdability, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  if (! args[0] || (args[1] && ! args[2])) {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, callablestatement) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new CallableStatement(callablestatement));\n    }\n  });\n\n  // Forward modified arguments to _conn.prepareCall\n  this._conn.prepareCall.apply(this._conn, args);\n};\n\nfunction allType(array, type) {\n  _.each(array, function(el) {\n    if (typeof el !== type) {\n      return false;\n    }\n  });\n\n  return true;\n}\n\n/**\n * @callback prepareStatementCallback\n * @param {Error} err - An error message, or null if no error occurred\n * @param {PreparedStatement} prepStmt - The prepared statement\n */\n\n/**\n * Creates a prepared statement and returns it via callback.\n *\n * @param {string} sql - SQL query\n * @param {(number | number[] | string[])} [arg1] - autoGeneratedKeys, resultSetType, or an array of numbers or strings\n * @param {number} [arg2] - resultSetConcurrency\n * @param {number} [arg3] - resultSetHoldability\n * @param {prepareStatementCallback} callback - The callback that handles the prepare statement response\n */\nConnection.prototype.prepareStatement = function(sql, arg1, arg2, arg3, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Error to return if arguments are invalid\n  var errMsg = 'INVALID ARGUMENTS';\n\n  // The first arg (sql) must be present\n  if (! args[0]) {\n    return callback(new Error(errMsg));\n  }\n\n  // Check arg1, arg2, and arg3 for validity.  These arguments must\n  // be numbers if given, except for the special case when the first\n  // of these arguments is an array and no other arguments are given.\n  // In this special case, the array must be a string or number array.\n  //\n  // NOTE: _.tail returns all but the first argument, so we are only\n  // processing arg1, arg2, and arg3; and not sql (or callback, which\n  // was already removed from the args array).\n  var invalidArgs = false;\n  _.forEach(_.tail(args), function(arg, idx) {\n    // Check for the special case where arg1 can be an array of strings or numbers\n    // if arg2 and arg3 are not given\n    if (idx === 0 && _.isArray(arg) && _.isUndefined(args[2]) && _.isUndefined(args[3])) {\n      if (! (allType(arg, 'string') || allType(arg, 'number'))) {\n        invalidArgs = true;\n\n        // Lodash break\n        return false;\n      }\n\n      // Lodash continue\n      return;\n    }\n\n    // Other than the special case above, these args must be numbers\n    if (! _.isNumber(arg)) {\n      invalidArgs = true;\n\n      // Lodash break\n      return false;\n    }\n  });\n\n  if (invalidArgs) {\n    return callback(new Error(errMsg));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, ps) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new PreparedStatement(ps));\n    }\n  });\n\n  // Forward modified arguments to _conn.prepareStatement\n  this._conn.prepareStatement.apply(this._conn, args);\n};\n\nConnection.prototype.releaseSavepoint = function(savepoint, callback) {\n  this._conn.releaseSavepoint(savepoint, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.rollback = function(savepoint, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  // if (! _.isObject(args[0])) {\n  //   return callback(new Error(\"INVALID ARGUMENTS\"));\n  // }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n\n  // Forward modified arguments to _conn.rollback\n  this._conn.rollback.apply(this._conn, args);\n};\n\nConnection.prototype.setAutoCommit = function(autocommit, callback) {\n  this._conn.setAutoCommit(autocommit, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setCatalog = function(catalog, callback) {\n  this._conn.setCatalog(catalog, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setClientInfo = function(props, name, value, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, manipulate the args array appropriately,\n  // and return error if invalid\n  if (_.isObject(args[0]) && _.isUndefined(args[1]) && _.isUndefined(args[2])) {\n    // Do nothing\n  } else if (_.isNull(args[0]) && _.isString(args[1]) && _.isString(args[2])) {\n    // Remove first argument (props) from args array\n    args.shift();\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n\n  // Forward modified arguments to _conn.setClientInfo\n  this._conn.setClientInfo.apply(this._conn, args);\n};\n\nConnection.prototype.setHoldability = function(holdability, callback) {\n  this._conn.setHoldability(holdability, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setNetworkTimeout = function(executor, ms, callback) {\n  return callback(new Error('NOT IMPLEMENTED'));\n};\n\nConnection.prototype.setReadOnly = function(readonly, callback) {\n  this._conn.setReadOnly(readonly, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setSavepoint = function(name, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  if (! (_.isUndefined(args[0]) || _.isString(args[0]))) {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, savepoint) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, savepoint);\n    }\n  });\n\n  // Forward modified arguments to _conn.setSavepoint\n  this._conn.setSavepoint.apply(this._conn, args);\n};\n\nConnection.prototype.setSchema = function(schema, callback) {\n  this._conn.setSchema(schema, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setTransactionIsolation = function(txniso, callback) {\n  this._conn.setTransactionIsolation(txniso, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nConnection.prototype.setTypeMap = function(map, callback) {\n  return callback(new Error('NOT IMPLEMENTED'));\n};\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/callablestatement.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar PreparedStatement = require('./preparedstatement');\n\nfunction CallableStatement(cs) {\n  PreparedStatement.call(this, cs);\n  this._cs = cs;\n}\n\nCallableStatement.prototype = Object.create(PreparedStatement.prototype);\nCallableStatement.prototype.constructor = CallableStatement;\n\nCallableStatement.prototype.getArray = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getArray(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getBigDecimal = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getBigDecimal(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getBlob = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getBlob(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getBoolean = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getBoolean(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getByte = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getByte(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getBytes = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getBytes(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getCharacterStream = function(arg1, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nCallableStatement.prototype.getClob = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getClob(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getDate = function(arg1, arg2, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  var validArgs = (\n    (_.isNumber(args[0]) || _.isString(args[0])) &&\n    (_.isUndefined(args[1]) || _.isObject(args[1]))\n  );\n  if (! validArgs) {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, result);\n    }\n  });\n\n  // Forward modified arguments to _cs.getDate\n  this._cs.getDate.apply(this._cs, args);\n};\n\nCallableStatement.prototype.getDouble = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getDouble(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getFloat = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getFloat(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getInt = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getInt(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getLong = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getLong(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getNCharacterStream = function(arg1, callback) {\n    return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nCallableStatement.prototype.getNClob = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getNClob(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getNString = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getNString(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getLong = function(arg1, callback) {\n  if (typeof arg1 === 'number' || typeof arg1 === 'string') {\n    this._cs.getLong(arg1, function(err, result) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, result);\n      }\n    });\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n};\n\nCallableStatement.prototype.getObject = function(arg1, arg2, callback) {\n  return callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nCallableStatement.prototype.registerOutParameter = function() { \n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop();\n  if ((typeof args[0] == 'number' && typeof args[1] == 'number') || \n     (typeof args[0] == 'number' && typeof args[1] == 'number' && typeof args[2] == 'number') ||\n     (typeof args[0] == 'number' && typeof args[1] == 'number' && typeof args[2] == 'string') || \n     (typeof args[0] == 'string' && typeof args[1] == 'number') || \n     (typeof args[0] == 'string' && typeof args[1] == 'number' && typeof args[2] == 'number') || \n     (typeof args[0] == 'string' && typeof args[1] == 'number' && typeof args[2] == 'string')) {\n    args.push(callback);\n    this._cs.registerOutParameter.apply(this._cs, args);\n  } else {\n    return callback(new Error(\"INVALID ARGUMENTS\"));\n  }\n}\n\nmodule.exports = CallableStatement;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/preparedstatement.js":"/* jshint node: true */\n\"use strict\";\nvar ResultSet = require('./resultset');\nvar ResultSetMetaData = require('./resultsetmetadata');\nvar Statement = require('./statement');\nvar winston = require('winston');\n\nfunction PreparedStatement(ps) {\n  Statement.call(this, ps);\n  this._ps = ps;\n}\n\nPreparedStatement.prototype = Object.create(Statement.prototype);\nPreparedStatement.prototype.constructor = PreparedStatement;\n\nPreparedStatement.prototype.addBatch = function(callback) {\n  this._ps.addBatch(function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.clearParameters = function(callback) {\n  this._ps.clearParameters(function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.execute = function(callback) {\n  this._ps.execute(function(err, result) {\n    if (err) { winston.error(err); return callback(err); }\n    callback(null, result);\n  });\n};\n\nPreparedStatement.prototype.executeQuery = function(callback) {\n  this._ps.executeQuery(function(err, resultset) {\n    if (err) { winston.error(err); return callback(err); }\n    callback(null, new ResultSet(resultset));\n  });\n};\n\nPreparedStatement.prototype.executeUpdate = function(callback) {\n  this._ps.executeUpdate(function(err, result) {\n    if (err) { winston.error(err); return callback(err); }\n    callback(null, result);\n  });\n};\n\nPreparedStatement.prototype.getMetaData = function(callback) {\n  this._ps.getMetaData(function(err, result) {\n    if (err) return callback(err);\n    callback(null, new ResultSetMetaData(result));\n  });\n};\n\nPreparedStatement.prototype.getParameterMetaData = function(callback) {\n  callback(new Error(\"NOT IMPLEMENTED\"));\n  // this._ps.getParameterMetaData(function(err, result) {\n  //   if (err) callback(err);\n  //   callback(null, result);\n  // });\n};\n\nPreparedStatement.prototype.setArray = function(index, val, callback) {\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nPreparedStatement.prototype.setAsciiStream = function(index, val, length, callback) {\n  // length is optional, or can be int or long.\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\n// val must be a java.math.BigDecimal\nPreparedStatement.prototype.setBigDecimal = function(index, val, callback) {\n  this._ps.setBigDecimal(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setBinaryStream = function(index, val, length, callback) {\n  // length is optional, or can be int or long.\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nPreparedStatement.prototype.setBlob = function(index, val, length, callback) {\n  // length is optional.  Must be java.lang.Long if supplied, only valid with\n  // InputStream.\n  // val can be java.sql.Blob or java.io.InputStream\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nPreparedStatement.prototype.setBoolean = function(index, val, callback) {\n  this._ps.setBoolean(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setByte = function(index, val, callback) {\n  this._ps.setByte(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setBytes = function(index, val, callback) {\n  this._ps.setBytes(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setCharacterStream = function(index, val, length, callback) {\n  // length is optional, or can be int or long.\n  // val must be a java.io.Reader\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nPreparedStatement.prototype.setClob = function(index, val, length, callback) {\n  // length is optional, must be a long, only valid with a java.io.Reader.\n  // val can be a java.io.Reader or a java.sql.Clob\n  callback(new Error(\"NOT IMPLEMENTED\"));\n};\n\nPreparedStatement.prototype.setDate = function(index, val, calendar, callback) {\n  if (calendar === null) {\n    this._ps.setDate(index, val, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  } else {\n    this._ps.setDate(index, val, calendar, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  }\n};\n\nPreparedStatement.prototype.setDouble = function(index, val, callback) {\n  this._ps.setDouble(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setFloat = function(index, val, callback) {\n  this._ps.setFloat(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setInt = function(index, val, callback) {\n  this._ps.setInt(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setLong = function(index, val, callback) {\n  this._ps.setLong(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setString = function(index, val, callback) {\n  this._ps.setString(index, val, function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n};\n\nPreparedStatement.prototype.setTime = function(index, val, calendar, callback) {\n  if (calendar === null) {\n    this._ps.setTime(index, val, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  } else {\n    this._ps.setTime(index, val, calendar, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  }\n};\n\nPreparedStatement.prototype.setTimestamp = function(index, val, calendar, callback) {\n  if (calendar === null) {\n    this._ps.setTimestamp(index, val, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  } else {\n    this._ps.setTimestamp(index, val, calendar, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  }\n};\n\nmodule.exports = PreparedStatement;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/resultset.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar jinst = require('./jinst');\nvar ResultSetMetaData = require('./resultsetmetadata');\nvar java = jinst.getInstance();\nvar winston = require('winston');\n\nif (!jinst.isJvmCreated()) {\n  jinst.addOption(\"-Xrs\");\n}\n\nfunction ResultSet(rs) {\n  this._rs = rs;\n  this._holdability = (function() {\n    var h = [];\n\n    h[java.getStaticFieldValue('java.sql.ResultSet', 'CLOSE_CURSORS_AT_COMMIT')] = 'CLOSE_CURSORS_AT_COMMIT';\n    h[java.getStaticFieldValue('java.sql.ResultSet', 'HOLD_CURSORS_OVER_COMMIT')] = 'HOLD_CURSORS_OVER_COMMIT';\n\n    return h;\n  })();\n  this._types = (function() {\n    var typeNames = [];\n\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"BIT\")]  = \"Boolean\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"TINYINT\")]  = \"Short\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"SMALLINT\")] = \"Short\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"INTEGER\")]  = \"Int\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"BIGINT\")]   = \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"FLOAT\")]    = \"Float\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"REAL\")]     = \"Float\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"DOUBLE\")]   = \"Double\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"NUMERIC\")]  = \"BigDecimal\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"DECIMAL\")]  = \"BigDecimal\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"CHAR\")]     = \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"VARCHAR\")]     =  \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"LONGVARCHAR\")] = \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"DATE\")] =  \"Date\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"TIME\")] =  \"Time\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"TIMESTAMP\")] = \"Timestamp\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"BOOLEAN\")] =  \"Boolean\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"NCHAR\")] =  \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"NVARCHAR\")] = \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"LONGNVARCHAR\")] = \"String\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"BINARY\")] = \"Bytes\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"VARBINARY\")] = \"Bytes\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"LONGVARBINARY\")] = \"Bytes\";\n    typeNames[java.getStaticFieldValue(\"java.sql.Types\", \"BLOB\")] = \"Bytes\";\n\n    return typeNames;\n  })();\n}\n\nResultSet.prototype.toObjArray = function(callback) {\n  this.toObject(function(err, result) {\n    if (err) return callback(err);\n    callback(null, result.rows);\n  });\n};\n\nResultSet.prototype.toObject = function(callback) {\n  this.toObjectIter(function(err, rs) {\n    if (err) return callback(err);\n\n    var rowIter = rs.rows;\n    var rows = [];\n    var row = rowIter.next();\n\n    while (!row.done) {\n      rows.push(row.value);\n      row = rowIter.next();\n    }\n\n    rs.rows = rows;\n    return callback(null, rs);\n  });\n};\n\nResultSet.prototype.toObjectIter = function(callback) {\n  var self = this;\n\n  self.getMetaData(function(err, rsmd) {\n    if (err) {\n      return callback(err);\n    } else {\n      var colsmetadata = [];\n\n      rsmd.getColumnCount(function(err, colcount) {\n        // Get some column metadata.\n        _.each(_.range(1, colcount + 1), function(i) {\n          colsmetadata.push({\n            label: rsmd._rsmd.getColumnLabelSync(i),\n            type: rsmd._rsmd.getColumnTypeSync(i)\n          });\n        });\n\n        callback(null, {\n          labels: _.map(colsmetadata, 'label'),\n          types: _.map(colsmetadata, 'type'),\n          rows: {\n            next: function() {\n              var nextRow = self._rs.nextSync();\n              if (! nextRow) {\n                return {done: true};\n              }\n\n              var result = {};\n\n              // loop through each column\n              _.each(_.range(1, colcount + 1), function(i) {\n                var cmd = colsmetadata[i-1];\n                var type = self._types[cmd.type] || 'String';\n                var getter = 'get' + type + 'Sync';\n\n                if (type === 'Date' || type === 'Time' || type === 'Timestamp') {\n                  var dateVal = self._rs[getter](i);\n                  result[cmd.label] = dateVal ? dateVal.toString() : null;\n                } else {\n                  // If the column is an integer and is null, set result to null and continue\n                  if (type === 'Int' && _.isNull(self._rs.getObjectSync(i))) {\n                    result[cmd.label] = null;\n                    return;\n                  }\n\n                  result[cmd.label] = self._rs[getter](i);\n                }\n              });\n\n              return {value: result, done: false};\n            }\n          }\n        });\n      });\n    }\n  });\n};\n\nResultSet.prototype.close = function(callback) {\n  this._rs.close(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nResultSet.prototype.getMetaData = function(callback) {\n  this._rs.getMetaData(function(err, rsmd) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, new ResultSetMetaData(rsmd));\n    }\n  });\n};\n\nmodule.exports = ResultSet;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/resultsetmetadata.js":"/* jshint node: true */\n\"use strict\";\nfunction ResultSetMetaData(rsmd) {\n  this._rsmd = rsmd;\n}\n\nResultSetMetaData.prototype.getColumnCount = function (callback) {\n  this._rsmd.getColumnCount(function(err, count) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, count);\n    }\n  });\n};\n\nmodule.exports = ResultSetMetaData;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/statement.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar ResultSet = require('./resultset');\nvar jinst = require('./jinst');\nvar java = jinst.getInstance();\n\nfunction Statement(s) {\n  this._s = s;\n}\n\nStatement.prototype.close = function(callback) {\n  this._s.close(function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nStatement.prototype.executeUpdate = function(sql, arg1, callback) {\n  // Get arguments as an array\n  var args = Array.prototype.slice.call(arguments);\n\n  // Pull the callback off the end of the arguments\n  callback = args.pop();\n\n  // Check arguments for validity, and return error if invalid\n  if(! (_.isString(args[0]) && _.isUndefined(args[1]))) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  // Push a callback handler onto the arguments\n  args.push(function(err, count) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, count);\n  });\n\n  // Forward modified arguments to _s.executeUpdate\n  this._s.executeUpdate.apply(this._s, args);\n};\n\nStatement.prototype.executeQuery = function(sql, callback) {\n  if (typeof sql === 'string') {\n    this._s.executeQuery(sql, function(err, resultset) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, new ResultSet(resultset));\n      }\n    });\n  } else {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n};\n\nStatement.prototype.execute = function(sql, callback) {\n  var s = this._s;\n  if (typeof sql === 'string') {\n    s.execute(sql, function(err, isResultSet) {\n      if (err) {\n        return callback(err);\n      }\n      if (isResultSet) {\n        s.getResultSet(function(err, resultset) {\n          if (err) {\n            return callback(err);\n          }\n          return callback(null, new ResultSet(resultset));\n        });\n      } else {\n        s.getUpdateCount(function(err, count) {\n          if (err) {\n            return callback(err);\n          }\n          return callback(null, count);\n        });\n      }\n    });\n  } else {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n};\n\nStatement.prototype.getFetchSize = function(callback) {\n  this._s.getFetchSize(function(err, fetchSize) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, fetchSize);\n    }\n  });\n};\n\nStatement.prototype.setFetchSize = function(rows, callback) {\n  this._s.setFetchSize(rows, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nStatement.prototype.getMaxRows = function(callback) {\n  this._s.getMaxRows(function(err, max) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, max);\n    }\n  });\n};\n\nStatement.prototype.setMaxRows = function(max, callback) {\n  this._s.setMaxRows(max, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nStatement.prototype.getQueryTimeout = function(callback) {\n  this._s.getQueryTimeout(function(err, queryTimeout) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, queryTimeout);\n    }\n  });\n};\n\nStatement.prototype.setQueryTimeout = function(seconds, callback) {\n  this._s.setQueryTimeout(seconds, function(err) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null);\n    }\n  });\n};\n\nStatement.prototype.getGeneratedKeys = function(callback) {\n  this._s.getGeneratedKeys(function(err, resultset) {\n    if(err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(resultset));\n  });\n};\n\njinst.events.once('initialized', function onInitialized() {\n  // The constant indicating that the current ResultSet object should be closed\n  // when calling getMoreResults.\n  Statement.CLOSE_CURRENT_RESULT = java.getStaticFieldValue('java.sql.Statement', 'CLOSE_CURRENT_RESULT');\n\n  // The constant indicating that the current ResultSet object should not be\n  // closed when calling getMoreResults.\n  Statement.KEEP_CURRENT_RESULT = java.getStaticFieldValue('java.sql.Statement', 'KEEP_CURRENT_RESULT');\n\n  // The constant indicating that all ResultSet objects that have previously been\n  // kept open should be closed when calling getMoreResults.\n  Statement.CLOSE_ALL_RESULTS = java.getStaticFieldValue('java.sql.Statement', 'CLOSE_ALL_RESULTS');\n\n  // The constant indicating that a batch statement executed successfully but that\n  // no count of the number of rows it affected is available.\n  Statement.SUCCESS_NO_INFO = java.getStaticFieldValue('java.sql.Statement', 'SUCCESS_NO_INFO');\n\n  // The constant indicating that an error occured while executing a batch\n  // statement.\n  Statement.EXECUTE_FAILED = java.getStaticFieldValue('java.sql.Statement', 'EXECUTE_FAILED');\n\n  // The constant indicating that generated keys should be made available for\n  // retrieval.\n  Statement.RETURN_GENERATED_KEYS = java.getStaticFieldValue('java.sql.Statement', 'RETURN_GENERATED_KEYS');\n\n  // The constant indicating that generated keys should not be made available for\n  // retrieval.\n  Statement.NO_GENERATED_KEYS = java.getStaticFieldValue('java.sql.Statement', 'NO_GENERATED_KEYS');\n});\n\nmodule.exports = Statement;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/databasemetadata.js":"/* jshint node: true */\n\"use strict\";\nvar _ = require('lodash');\nvar ResultSet = require('./resultset');\nvar Connection = require('./connection');\nvar jinst = require('./jinst');\nvar java = jinst.getInstance();\n\nfunction DatabaseMetaData(dbm) {\n  this._dbm = dbm;\n}\n\n/**\n * Retrieves the schema names available in this database.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is a schema description\n */\nDatabaseMetaData.prototype.getSchemas = function(catalog, schemaPattern, callback) {\n  if(_.isFunction(catalog)) {\n    callback = catalog;\n    catalog = null;\n  } else if(_.isFunction(schemaPattern)) {\n    callback = schemaPattern;\n    schemaPattern = null;\n  }\n\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getSchemas(catalog, schemaPattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the tables available in the given catalog.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} tableNamePattern - A table name pattern; must match the table name as it is stored in the database\n * @param {String[]} types -  A list of table types, which must be from the list of table types returned from getTableTypes(),to include; null returns all types\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a table description\n */\nDatabaseMetaData.prototype.getTables = function(catalog, schemaPattern, tableNamePattern, types, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(tableNamePattern) || _.isUndefined(tableNamePattern) || _.isString(tableNamePattern)) &&\n    (_.isNull(types) || _.isUndefined(types) || _.isArray(types))\n  );\n\n  if(_.isArray(types)) {\n    _.forEach(types, function(type) {\n      if(_.isString(type)) return;\n      validParams = false;\n      return false;\n    });\n  }\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getTables(catalog, schemaPattern, tableNamePattern, types, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves whether the current user can call all the procedures returned by\n * the method getProcedures.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.allProceduresAreCallable = function(callback) {\n  this._dbm.allProceduresAreCallable(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether the current user can use all the tables returned by the\n * method getTables in a SELECT statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.allTablesAreSelectable = function(callback) {\n  this._dbm.allTablesAreSelectable(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a SQLException while autoCommit is true inidcates that all\n * open ResultSets are closed, even ones that are holdable.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.autoCommitFailureClosesAllResultSets = function(callback) {\n  this._dbm.autoCommitFailureClosesAllResultSets(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a data definition statement within a transaction forces\n * the transaction to commit.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.dataDefinitionCausesTransactionCommit = function(callback) {\n  this._dbm.dataDefinitionCausesTransactionCommit(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database ignores a data definition statement within a\n * transaction.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.dataDefinitionIgnoredInTransactions = function(callback) {\n  this._dbm.dataDefinitionIgnoredInTransactions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether or not a visible row delete can be detected by calling the\n * method ResultSet.rowDeleted.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if deletes are detected by the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.deletesAreDetected = function(type, callback) {\n  var validParams = _.isInteger(type);\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.deletesAreDetected(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether the return value for the method getMaxRowSize includes the\n * SQL data types LONGVARCHAR and LONGVARBINARY.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.doesMaxRowSizeIncludeBlobs = function(callback) {\n  this._dbm.doesMaxRowSizeIncludeBlobs(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a generated key will always be returned if the column\n * name(s) or index(es) specified for the auto generated key column(s) are\n * valid and the statement succeeds.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.generatedKeyAlwaysReturned = function(callback) {\n  this._dbm.generatedKeyAlwaysReturned(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the given attribute of the given type for a\n * user-defined type (UDT) that is available in the given schema and catalog.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} typeNamePattern - A type name pattern; must match the type name as it is stored in the database\n * @param {String} attributeNamePattern - An attribute name pattern; must match the attribute name as it is declared in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is an attribute description\n */\nDatabaseMetaData.prototype.getAttributes = function(catalog, schemaPattern, typeNamePattern, attributeNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(typeNamePattern) || _.isUndefined(typeNamePattern) || _.isString(typeNamePattern)) &&\n    (_.isNull(attributeNamePattern) || _.isUndefined(attributeNamePattern) || _.isString(attributeNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getAttributes(catalog, schemaPattern, typeNamePattern, attributeNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of a table's optimal set of columns that uniquely\n * identifies a row.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in the database\n * @param {Number} scope - The scope of interest; use same values as SCOPE\n * @param {Boolean} nullable - Include columns that are nullable\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a column description\n */\nDatabaseMetaData.prototype.getBestRowIdentifier = function(catalog, schema, table, scope, nullable, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table) &&\n    _.isInteger(scope) &&\n    _.isBoolean(nullable)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getBestRowIdentifier(catalog, schema, table, scope, nullable, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the catalog names available in this database.\n *\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row has a single String column that is a catalog name\n */\nDatabaseMetaData.prototype.getCatalogs = function(callback) {\n  this._dbm.getCatalogs(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the String that this database uses as the separator between a\n * catalog and table name.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the separator string\n */\nDatabaseMetaData.prototype.getCatalogSeparator = function(callback) {\n  this._dbm.getCatalogSeparator(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the database vendor's preferred term for \"catalog\".\n *\n * @param {Function} callback\n * @returns {String} Via callback: the vendor term for \"catalog\"\n */\nDatabaseMetaData.prototype.getCatalogTerm = function(callback) {\n  this._dbm.getCatalogTerm(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a list of the client info properties that the driver supports.\n *\n * @param {Function} callback\n * @returns {ResultSet} Via callback: A ResultSet object; each row is a supported client info property\n */\nDatabaseMetaData.prototype.getClientInfoProperties = function(callback) {\n  this._dbm.getClientInfoProperties(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the access rights for a table's columns.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in the database\n * @param {String} columnNamePattern - A column name pattern; must match the column name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a column privilege description\n */\nDatabaseMetaData.prototype.getColumnPrivileges = function(catalog, schema, table, columnNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table) &&\n    (_.isNull(columnNamePattern) || _.isUndefined(columnNamePattern) || _.isString(columnNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getColumnPrivileges(catalog, schema, table, columnNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of table columns available in the specified catalog.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} tableNamePattern - A table name pattern; must match the table name as it is stored in the database\n * @param {String} columnNamePattern - A column name pattern; must match the column name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a column description\n */\nDatabaseMetaData.prototype.getColumns = function(catalog, schemaPattern, tableNamePattern, columnNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(tableNamePattern) || _.isUndefined(tableNamePattern) || _.isString(tableNamePattern)) &&\n    (_.isNull(columnNamePattern) || _.isUndefined(columnNamePattern) || _.isString(columnNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the connection that produced this metadata object.\n *\n * @param {Function} callback\n * @returns {Connection} Via callback: the connection that produced this metadata object\n */\nDatabaseMetaData.prototype.getConnection = function(callback) {\n  this._dbm.getConnection(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new Connection(result));\n  });\n};\n\n/**\n * Retrieves a description of the foreign key columns in the given foreign key\n * table that reference the primary key or the columns representing a unique\n * constraint of the parent table (could be the same or a different table).\n *\n * @param {String} parentCatalog - A catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means drop catalog name from the selection criteria\n * @param {String} parentSchema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means drop schema name from the selection criteria\n * @param {String} parentTable - The name of the table that exports the key; must match the table name as it is stored in the database\n * @param {String} foreignCatalog - A catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means drop catalog name from the selection criteria\n * @param {String} foreignSchema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means drop schema name from the selection criteria\n * @param {String} foreignTable - The name of the table that imports the key; must match the table name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a foreign key column description\n */\nDatabaseMetaData.prototype.getCrossReference = function(parentCatalog, parentSchema, parentTable, foreignCatalog, foreignSchema, foreignTable, callback) {\n  var validParams = (\n    (_.isNull(parentCatalog) || _.isUndefined(parentCatalog) || _.isString(parentCatalog)) &&\n    (_.isNull(parentSchema) || _.isUndefined(parentSchema) || _.isString(parentSchema)) &&\n    _.isString(parentTable) &&\n    (_.isNull(foreignCatalog) || _.isUndefined(foreignCatalog) || _.isString(foreignCatalog)) &&\n    (_.isNull(foreignSchema) || _.isUndefined(foreignSchema) || _.isString(foreignSchema)) &&\n    _.isString(foreignTable)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getCrossReference(parentCatalog, parentSchema, parentTable, foreignCatalog, foreignSchema, foreignTable, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the major version number of the underlying database.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the underlying database's major version\n */\nDatabaseMetaData.prototype.getDatabaseMajorVersion = function(callback) {\n  this._dbm.getDatabaseMajorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the minor version number of the underlying database.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: underlying database's minor version\n */\nDatabaseMetaData.prototype.getDatabaseMinorVersion = function(callback) {\n  this._dbm.getDatabaseMinorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the name of this database product.\n *\n * @param {Function} callback\n * @returns {String} Via callback: database product name\n */\nDatabaseMetaData.prototype.getDatabaseProductName = function(callback) {\n  this._dbm.getDatabaseProductName(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the version number of this database product.\n *\n * @param {Function} callback\n * @returns {String} Via callback: database version number\n */\nDatabaseMetaData.prototype.getDatabaseProductVersion = function(callback) {\n  this._dbm.getDatabaseProductVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves this database's default transaction isolation level.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the default isolation level\n */\nDatabaseMetaData.prototype.getDefaultTransactionIsolation = function(callback) {\n  this._dbm.getDefaultTransactionIsolation(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves this JDBC driver's major version number.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: JDBC driver major version\n */\nDatabaseMetaData.prototype.getDriverMajorVersion = function(callback) {\n  this._dbm.getDriverMajorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves this JDBC driver's minor version number.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: JDBC driver minor version\n */\nDatabaseMetaData.prototype.getDriverMinorVersion = function(callback) {\n  this._dbm.getDriverMinorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the name of this JDBC driver.\n *\n * @param {Function} callback\n * @returns {String} Via callback: JDBC driver name\n */\nDatabaseMetaData.prototype.getDriverName = function(callback) {\n  this._dbm.getDriverName(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the version number of this JDBC driver as a String.\n *\n * @param {Function} callback\n * @returns {String} Via callback: JDBC driver version\n */\nDatabaseMetaData.prototype.getDriverVersion = function(callback) {\n  this._dbm.getDriverVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the foreign key columns that reference the given\n * table's primary key columns (the foreign keys exported by a table).\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in this database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is a foreign key column description\n */\nDatabaseMetaData.prototype.getExportedKeys = function(catalog, schema, table, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getExportedKeys(catalog, schema, table, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves all the \"extra\" characters that can be used in unquoted identifier\n * names (those beyond a-z, A-Z, 0-9 and _).\n *\n * @param {Function} callback\n * @returns {String} Via callback: the string containing the extra characters\n */\nDatabaseMetaData.prototype.getExtraNameCharacters = function(callback) {\n  this._dbm.getExtraNameCharacters(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the given catalog's system or user function\n * parameters and return type.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} functionNamePattern - A procedure name pattern; must match the function name as it is stored in the database\n * @param {String} columnNamePattern - A column name pattern; must match the column name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row describes a user function parameter, column or return type\n */\nDatabaseMetaData.prototype.getFunctionColumns = function(catalog, schemaPattern, functionNamePattern, columnNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(functionNamePattern) || _.isUndefined(functionNamePattern) || _.isString(functionNamePattern)) &&\n    (_.isNull(columnNamePattern) || _.isUndefined(columnNamePattern) || _.isString(columnNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getFunctionColumns(catalog, schemaPattern, functionNamePattern, columnNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the system and user functions available in the\n * given catalog.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} functionNamePattern - A procedure name pattern; must match the function name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a function description\n */\nDatabaseMetaData.prototype.getFunctions = function(catalog, schemaPattern, functionNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(functionNamePattern) || _.isUndefined(functionNamePattern) || _.isString(functionNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getFunctions(catalog, schemaPattern, functionNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the string used to quote SQL identifiers.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the quoting string or a space if quoting is not supported\n */\nDatabaseMetaData.prototype.getIdentifierQuoteString = function(callback) {\n  this._dbm.getIdentifierQuoteString(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the primary key columns that are referenced by\n * the given table's foreign key columns (the primary keys imported by a\n * table).\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in this database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a primary key column description\n */\nDatabaseMetaData.prototype.getImportedKeys = function(catalog, schema, table, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getImportedKeys(catalog, schema, table, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the given table's indices and statistics.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in this database\n * @param {Boolean} unique - When true, return only indices for unique values; when false, return indices regardless of whether unique or not\n * @param {Boolean} approximate - When true, result is allowed to reflect approximate or out of data values; when false, results are requested to be accurate\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is an index column description\n */\nDatabaseMetaData.prototype.getIndexInfo = function(catalog, schema, table, unique, approximate, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table) &&\n    _.isBoolean(unique) &&\n    _.isBoolean(approximate)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getIndexInfo(catalog, schema, table, unique, approximate, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the major JDBC version number for this driver.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: JDBC version major number\n */\nDatabaseMetaData.prototype.getJDBCMajorVersion = function(callback) {\n  this._dbm.getJDBCMajorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the minor JDBC version number for this driver.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: JDBC version minor number\n */\nDatabaseMetaData.prototype.getJDBCMinorVersion = function(callback) {\n  this._dbm.getJDBCMinorVersion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of hex characters this database allows in an\n * inline binary literal.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum length (in hex characters) for a binary literal; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxBinaryLiteralLength = function(callback) {\n  this._dbm.getMaxBinaryLiteralLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters that this database allows in a\n * catalog name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed in a catalog name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxCatalogNameLength = function(callback) {\n  this._dbm.getMaxCatalogNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters this database allows for a\n * character literal.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed for a character literal; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxCharLiteralLength = function(callback) {\n  this._dbm.getMaxCharLiteralLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters this database allows for a column\n * name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed for a column name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnNameLength = function(callback) {\n  this._dbm.getMaxColumnNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of columns this database allows in a GROUP BY\n * clause.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of columns allowed; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnsInGroupBy = function(callback) {\n  this._dbm.getMaxColumnsInGroupBy(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of columns this database allows in an index.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of columns allowed; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnsInIndex = function(callback) {\n  this._dbm.getMaxColumnsInIndex(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of columns this database allows in an ORDER BY\n * clause.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of columns allowed; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnsInOrderBy = function(callback) {\n  this._dbm.getMaxColumnsInOrderBy(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of columns this database allows in a SELECT\n * list.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of columns allowed; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnsInSelect = function(callback) {\n  this._dbm.getMaxColumnsInSelect(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of columns this database allows in a table.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of columns allowed; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxColumnsInTable = function(callback) {\n  this._dbm.getMaxColumnsInTable(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of concurrent connections to this database that\n * are possible.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of active connections possible at one time; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxConnections = function(callback) {\n  this._dbm.getMaxConnections(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters that this database allows in a\n * cursor name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed in a cursor name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxCursorNameLength = function(callback) {\n  this._dbm.getMaxCursorNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of bytes this database allows for an index,\n * including all of the parts of the index.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of bytes allowed; this limit includes the composite of all the constituent parts of the index; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxIndexLength = function(callback) {\n  this._dbm.getMaxIndexLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters that this database allows in a\n * procedure name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed in a procedure name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxProcedureNameLength = function(callback) {\n  this._dbm.getMaxProcedureNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of bytes this database allows in a single row.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of bytes allowed for a row; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxRowSize = function(callback) {\n  this._dbm.getMaxRowSize(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters that this database allows in a\n * schema name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed in a schema name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxSchemaNameLength = function(callback) {\n  this._dbm.getMaxSchemaNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters this database allows in an SQL\n * statement.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed for an SQL statement; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxStatementLength = function(callback) {\n  this._dbm.getMaxStatementLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of active statements to this database that can\n * be open at the same time.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of statements that can be open at one time; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxStatements = function(callback) {\n  this._dbm.getMaxStatements(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters this database allows in a table\n * name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed for a table name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxTableNameLength = function(callback) {\n  this._dbm.getMaxTableNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of tables this database allows in a SELECT\n * statement.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of tables allowed in a SELECT statement; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxTablesInSelect = function(callback) {\n  this._dbm.getMaxTablesInSelect(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the maximum number of characters this database allows in a user\n * name.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the maximum number of characters allowed for a user name; a result of zero means that there is no limit or the limit is not known\n */\nDatabaseMetaData.prototype.getMaxUserNameLength = function(callback) {\n  this._dbm.getMaxUserNameLength(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a comma-separated list of math functions available with this\n * database.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the list of math functions supported by this database\n */\nDatabaseMetaData.prototype.getNumericFunctions = function(callback) {\n  this._dbm.getNumericFunctions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the given table's primary key columns.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in this database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a primary key column description\n */\nDatabaseMetaData.prototype.getPrimaryKeys = function(catalog, schema, table, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getPrimaryKeys(catalog, schema, table, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the given catalog's stored procedure parameter\n * and result columns.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} procedureNamePattern - A procedure name pattern; must match the procedure name as it is stored in the database\n * @param {String} columnNamePattern - A column name pattern; must match the column name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row describes a stored procedure parameter or column\n */\nDatabaseMetaData.prototype.getProcedureColumns = function(catalog, schemaPattern, procedureNamePattern, columnNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(procedureNamePattern) || _.isUndefined(procedureNamePattern) || _.isString(procedureNamePattern)) &&\n    (_.isNull(columnNamePattern) || _.isUndefined(columnNamePattern) || _.isString(columnNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getProcedureColumns(catalog, schemaPattern, procedureNamePattern, columnNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the stored procedures available in the given\n * catalog.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} procedureNamePattern - A procedure name pattern; must match the procedure name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a procedure description\n */\nDatabaseMetaData.prototype.getProcedures = function(catalog, schemaPattern, procedureNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(procedureNamePattern) || _.isUndefined(procedureNamePattern) || _.isString(procedureNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getProcedures(catalog, schemaPattern, procedureNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the database vendor's preferred term for \"procedure\".\n *\n * @param {Function} callback\n * @returns {String} Via callback: the vendor term for \"procedure\"\n */\nDatabaseMetaData.prototype.getProcedureTerm = function(callback) {\n  this._dbm.getProcedureTerm(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the pseudo or hidden columns available in a given\n * table within the specified catalog and schema.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} tableNamePattern - A table name pattern; must match the table name as it is stored in the database\n * @param {String} columnNamePattern - A column name pattern; must match the column name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a column description\n */\nDatabaseMetaData.prototype.getPseudoColumns = function(catalog, schemaPattern, tableNamePattern, columnNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(tableNamePattern) || _.isUndefined(tableNamePattern) || _.isString(tableNamePattern)) &&\n    (_.isNull(columnNamePattern) || _.isUndefined(columnNamePattern) || _.isString(columnNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getPseudoColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves this database's default holdability for ResultSet objects.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the default holdability; either ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT\n */\nDatabaseMetaData.prototype.getResultSetHoldability = function(callback) {\n  this._dbm.getResultSetHoldability(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Indicates whether or not this data source supports the SQL ROWID type, and\n * if so the lifetime for which a RowId object remains valid.\n *\n * NOTE: This method should be used with caution for now. The RowIdLifetime object\n * returned is a Java object and is not wrapped by the node-jdbc library.\n *\n * @param {Function} callback\n * @returns {RowIdLifetime} Via callback: the status indicating the lifetime of a RowId\n */\nDatabaseMetaData.prototype.getRowIdLifetime = function(callback) {\n  this._dbm.getRowIdLifetime(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the database vendor's preferred term for \"schema\".\n *\n * @param {Function} callback\n * @returns {String} Via callback: the vendor term for \"schema\"\n */\nDatabaseMetaData.prototype.getSchemaTerm = function(callback) {\n  this._dbm.getSchemaTerm(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the string that can be used to escape wildcard characters.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the string used to escape wildcard characters\n */\nDatabaseMetaData.prototype.getSearchStringEscape = function(callback) {\n  this._dbm.getSearchStringEscape(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a comma-separated list of all of this database's SQL keywords that\n * are NOT also SQL:2003 keywords.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the list of this database's keywords that are not also SQL:2003 keywords\n */\nDatabaseMetaData.prototype.getSQLKeywords = function(callback) {\n  this._dbm.getSQLKeywords(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Indicates whether the SQLSTATE returned by SQLException.getSQLState is\n * X/Open (now known as Open Group) SQL CLI or SQL:2003.\n *\n * @param {Function} callback\n * @returns {Number} Via callback: the type of SQLSTATE; one of: sqlStateXOpen or sqlStateSQL\n */\nDatabaseMetaData.prototype.getSQLStateType = function(callback) {\n  this._dbm.getSQLStateType(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a comma-separated list of string functions available with this\n * database.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the list of string functions supported by this database\n */\nDatabaseMetaData.prototype.getStringFunctions = function(callback) {\n  this._dbm.getStringFunctions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the table hierarchies defined in a particular\n * schema in this database.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} tableNamePattern - A table name pattern; must match the table name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is a type description\n */\nDatabaseMetaData.prototype.getSuperTables = function(catalog, schemaPattern, tableNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(tableNamePattern) || _.isUndefined(tableNamePattern) || _.isString(tableNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getSuperTables(catalog, schemaPattern, tableNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the user-defined type (UDT) hierarchies defined\n * in a particular schema in this database.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} typeNamePattern - A UDT name pattern; may be a fully-qualified name\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which a row gives information about the designated UDT\n */\nDatabaseMetaData.prototype.getSuperTypes = function(catalog, schemaPattern, typeNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(typeNamePattern) || _.isUndefined(typeNamePattern) || _.isString(typeNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getSuperTypes(catalog, schemaPattern, typeNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a comma-separated list of system functions available with this\n * database.\n *\n * @param {Function} callback\n * @returns {String} Via callback: a list of system functions supported by this database\n */\nDatabaseMetaData.prototype.getSystemFunctions = function(callback) {\n  this._dbm.getSystemFunctions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of the access rights for each table available in a\n * catalog.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} tableNamePattern - A table name pattern; must match the table name as it is stored in the database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: each row is a table privilege description\n */\nDatabaseMetaData.prototype.getTablePrivileges = function(catalog, schemaPattern, tableNamePattern, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(tableNamePattern) || _.isUndefined(tableNamePattern) || _.isString(tableNamePattern))\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getTablePrivileges(catalog, schemaPattern, tableNamePattern, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the table types available in this database.\n *\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row has a single String column that is a table type\n */\nDatabaseMetaData.prototype.getTableTypes = function(callback) {\n  this._dbm.getTableTypes(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a comma-separated list of the time and date functions available\n * with this database.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the list of time and date functions supported by this database\n */\nDatabaseMetaData.prototype.getTimeDateFunctions = function(callback) {\n  this._dbm.getTimeDateFunctions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of all the data types supported by this database.\n *\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is an SQL type description\n */\nDatabaseMetaData.prototype.getTypeInfo = function(callback) {\n  this._dbm.getTypeInfo(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves a description of the user-defined types (UDTs) defined in a\n * particular schema.\n *\n * @param {String} catalog - A  catalog name; must match the catalog name as it is stored in the database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schemaPattern - A schema name pattern; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} typeNamePattern - A UDT name pattern; may be a fully-qualified name\n * @param {Number[]} types - A list of user-defined types (JAVA_OBJECT, STRUCT, or DISTINCT) to include; null returns all types\n * @param {Function} callback\n * @returns {ResultSet} Via callback: ResultSet object in which each row describes a UDT\n */\nDatabaseMetaData.prototype.getUDTs = function(catalog, schemaPattern, typeNamePattern, types, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schemaPattern) || _.isUndefined(schemaPattern) || _.isString(schemaPattern)) &&\n    (_.isNull(typeNamePattern) || _.isUndefined(typeNamePattern) || _.isString(typeNamePattern)) &&\n    (_.isNull(types) || _.isUndefined(types) || _.isArray(types))\n  );\n\n  if(_.isArray(types)) {\n    _.forEach(types, function(type) {\n      if(_.isInteger(type)) return;\n      validParams = false;\n      return false;\n    });\n  }\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getUDTs(catalog, schemaPattern, typeNamePattern, types, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves the URL for this DBMS.\n *\n * @param {Function} callback\n * @returns {String} Via callback: the URL for this DBMS or null if it cannot be generated\n */\nDatabaseMetaData.prototype.getURL = function(callback) {\n  this._dbm.getURL(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves the user name as known to this database.\n *\n * @param {Function} callback\n * @returns {String} Via callback: Retrieves the user name as known to this database\n */\nDatabaseMetaData.prototype.getUserName = function(callback) {\n  this._dbm.getUserName(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves a description of a table's columns that are automatically updated\n * when any value in a row is updated.\n *\n * @param {String} catalog - A catalog name; must match the catalog name as it is stored in this database; \"\" retrieves those without a catalog; null means that the catalog name should not be used to narrow the search\n * @param {String} schema - A schema name; must match the schema name as it is stored in the database; \"\" retrieves those without a schema; null means that the schema name should not be used to narrow the search\n * @param {String} table - A table name; must match the table name as it is stored in this database\n * @param {Function} callback\n * @returns {ResultSet} Via callback: a ResultSet object in which each row is a column description\n */\nDatabaseMetaData.prototype.getVersionColumns = function(catalog, schema, table, callback) {\n  var validParams = (\n    (_.isNull(catalog) || _.isUndefined(catalog) || _.isString(catalog)) &&\n    (_.isNull(schema) || _.isUndefined(schema) || _.isString(schema)) &&\n    _.isString(table)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.getVersionColumns(catalog, schema, table, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, new ResultSet(result));\n  });\n};\n\n/**\n * Retrieves whether or not a visible row insert can be detected by calling the\n * method ResultSet.rowInserted.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if changes are detected by the specified result set type; false otherwise\n */\nDatabaseMetaData.prototype.insertsAreDetected = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.insertsAreDetected(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog appears at the start of a fully qualified table\n * name.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.isCatalogAtStart = function(callback) {\n  this._dbm.isCatalogAtStart(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database is in read-only mode.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.isReadOnly = function(callback) {\n  this._dbm.isReadOnly(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Indicates whether updates made to a LOB are made on a copy or directly to\n * the LOB.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if updates are made to a copy of the LOB; false if updates are made directly to the LOB\n */\nDatabaseMetaData.prototype.locatorsUpdateCopy = function(callback) {\n  this._dbm.locatorsUpdateCopy(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports concatenations between NULL and\n * non-NULL values being NULL.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.nullPlusNonNullIsNull = function(callback) {\n  this._dbm.nullPlusNonNullIsNull(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether NULL values are sorted at the end regardless of sort\n * order.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.nullsAreSortedAtEnd = function(callback) {\n  this._dbm.nullsAreSortedAtEnd(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether NULL values are sorted at the start regardless of sort\n * order.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.nullsAreSortedAtStart = function(callback) {\n  this._dbm.nullsAreSortedAtStart(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether NULL values are sorted high.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.nullsAreSortedHigh = function(callback) {\n  this._dbm.nullsAreSortedHigh(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether NULL values are sorted low.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.nullsAreSortedLow = function(callback) {\n  this._dbm.nullsAreSortedLow(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether deletes made by others are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if deletes made by others are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.othersDeletesAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.othersDeletesAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether inserts made by others are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if inserts made by others are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.othersInsertsAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.othersInsertsAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether updates made by others are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if updates made by others are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.othersUpdatesAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.othersUpdatesAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a result set's own deletes are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if deletes are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.ownDeletesAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.ownDeletesAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a result set's own inserts are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if inserts are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.ownInsertsAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.ownInsertsAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether for the given type of ResultSet object, the result set's\n * own updates are visible.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if updates are visible for the given result set type; false otherwise\n */\nDatabaseMetaData.prototype.ownUpdatesAreVisible = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.ownUpdatesAreVisible(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case unquoted SQL identifiers\n * as case insensitive and stores them in lower case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesLowerCaseIdentifiers = function(callback) {\n  this._dbm.storesLowerCaseIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case quoted SQL identifiers as\n * case insensitive and stores them in lower case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesLowerCaseQuotedIdentifiers = function(callback) {\n  this._dbm.storesLowerCaseQuotedIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case unquoted SQL identifiers\n * as case insensitive and stores them in mixed case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesMixedCaseIdentifiers = function(callback) {\n  this._dbm.storesMixedCaseIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case quoted SQL identifiers as\n * case insensitive and stores them in mixed case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesMixedCaseQuotedIdentifiers = function(callback) {\n  this._dbm.storesMixedCaseQuotedIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case unquoted SQL identifiers\n * as case insensitive and stores them in upper case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesUpperCaseIdentifiers = function(callback) {\n  this._dbm.storesUpperCaseIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case quoted SQL identifiers as\n * case insensitive and stores them in upper case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.storesUpperCaseQuotedIdentifiers = function(callback) {\n  this._dbm.storesUpperCaseQuotedIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports ALTER TABLE with add column.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsAlterTableWithAddColumn = function(callback) {\n  this._dbm.supportsAlterTableWithAddColumn(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports ALTER TABLE with drop column.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsAlterTableWithDropColumn = function(callback) {\n  this._dbm.supportsAlterTableWithDropColumn(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ANSI92 entry level SQL grammar.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsANSI92EntryLevelSQL = function(callback) {\n  this._dbm.supportsANSI92EntryLevelSQL(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ANSI92 full SQL grammar\n * supported.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsANSI92FullSQL = function(callback) {\n  this._dbm.supportsANSI92FullSQL(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ANSI92 intermediate SQL grammar\n * supported.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsANSI92IntermediateSQL = function(callback) {\n  this._dbm.supportsANSI92IntermediateSQL(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports batch updates.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if this database supports batch upcates; false otherwise\n */\nDatabaseMetaData.prototype.supportsBatchUpdates = function(callback) {\n  this._dbm.supportsBatchUpdates(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog name can be used in a data manipulation\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCatalogsInDataManipulation = function(callback) {\n  this._dbm.supportsCatalogsInDataManipulation(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog name can be used in an index definition\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCatalogsInIndexDefinitions = function(callback) {\n  this._dbm.supportsCatalogsInIndexDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog name can be used in a privilege definition\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCatalogsInPrivilegeDefinitions = function(callback) {\n  this._dbm.supportsCatalogsInPrivilegeDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog name can be used in a procedure call statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCatalogsInProcedureCalls = function(callback) {\n  this._dbm.supportsCatalogsInProcedureCalls(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a catalog name can be used in a table definition\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCatalogsInTableDefinitions = function(callback) {\n  this._dbm.supportsCatalogsInTableDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports column aliasing.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsColumnAliasing = function(callback) {\n  this._dbm.supportsColumnAliasing(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the JDBC scalar function CONVERT\n * for the conversion of one JDBC type to another, or between the JDBC types\n * fromType and toType if both are given.\n *\n * @param {Number} [fromType] - The type to convert from; one of the type codes from the class java.sql.Types\n * @param {Number} [toType] - The type to convert to; one of the type codes from the class java.sql.Types\n * @param {Function} callback\n * @returns {Boolean}  Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsConvert = function(fromType, toType, callback) {\n  var validParams = (\n    _.isInteger(fromType) &&\n    _.isInteger(toType)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.supportsConvert(fromType, toType, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ODBC Core SQL grammar.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCoreSQLGrammar = function(callback) {\n  this._dbm.supportsCoreSQLGrammar(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports correlated subqueries.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsCorrelatedSubqueries = function(callback) {\n  this._dbm.supportsCorrelatedSubqueries(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports both data definition and data\n * manipulation statements within a transaction.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsDataDefinitionAndDataManipulationTransactions = function(callback) {\n  this._dbm.supportsDataDefinitionAndDataManipulationTransactions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports only data manipulation statements\n * within a transaction.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsDataManipulationTransactionsOnly = function(callback) {\n  this._dbm.supportsDataManipulationTransactionsOnly(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether, when table correlation names are supported, they are\n * restricted to being different from the names of the tables.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsDifferentTableCorrelationNames = function(callback) {\n  this._dbm.supportsDifferentTableCorrelationNames(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports expressions in ORDER BY lists.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsExpressionsInOrderBy = function(callback) {\n  this._dbm.supportsExpressionsInOrderBy(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ODBC Extended SQL grammar.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsExtendedSQLGrammar = function(callback) {\n  this._dbm.supportsExtendedSQLGrammar(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports full nested outer joins.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsFullOuterJoins = function(callback) {\n  this._dbm.supportsFullOuterJoins(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether auto-generated keys can be retrieved after a statement has\n * been executed\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsGetGeneratedKeys = function(callback) {\n  this._dbm.supportsGetGeneratedKeys(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports some form of GROUP BY clause.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsGroupBy = function(callback) {\n  this._dbm.supportsGroupBy(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports using columns not included in the\n * SELECT statement in a GROUP BY clause provided that all of the columns in\n * the SELECT statement are included in the GROUP BY clause.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsGroupByBeyondSelect = function(callback) {\n  this._dbm.supportsGroupByBeyondSelect(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports using a column that is not in the\n * SELECT statement in a GROUP BY clause.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsGroupByUnrelated = function(callback) {\n  this._dbm.supportsGroupByUnrelated(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the SQL Integrity Enhancement\n * Facility.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsIntegrityEnhancementFacility = function(callback) {\n  this._dbm.supportsIntegrityEnhancementFacility(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports specifying a LIKE escape clause.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsLikeEscapeClause = function(callback) {\n  this._dbm.supportsLikeEscapeClause(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database provides limited support for outer joins.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsLimitedOuterJoins = function(callback) {\n  this._dbm.supportsLimitedOuterJoins(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the ODBC Minimum SQL grammar.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMinimumSQLGrammar = function(callback) {\n  this._dbm.supportsMinimumSQLGrammar(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case unquoted SQL identifiers\n * as case sensitive and as a result stores them in mixed case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMixedCaseIdentifiers = function(callback) {\n  this._dbm.supportsMixedCaseIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database treats mixed case quoted SQL identifiers as\n * case sensitive and as a result stores them in mixed case.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMixedCaseQuotedIdentifiers = function(callback) {\n  this._dbm.supportsMixedCaseQuotedIdentifiers(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether it is possible to have multiple ResultSet objects returned\n * from a CallableStatement object simultaneously.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMultipleOpenResults = function(callback) {\n  this._dbm.supportsMultipleOpenResults(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports getting multiple ResultSet objects\n * from a single call to the method execute.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMultipleResultSets = function(callback) {\n  this._dbm.supportsMultipleResultSets(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database allows having multiple transactions open at\n * once (on different connections).\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsMultipleTransactions = function(callback) {\n  this._dbm.supportsMultipleTransactions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports named parameters to callable\n * statements.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsNamedParameters = function(callback) {\n  this._dbm.supportsNamedParameters(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether columns in this database may be defined as non-nullable.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsNonNullableColumns = function(callback) {\n  this._dbm.supportsNonNullableColumns(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports keeping cursors open across\n * commits.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOpenCursorsAcrossCommit = function(callback) {\n  this._dbm.supportsOpenCursorsAcrossCommit(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports keeping cursors open across\n * rollbacks.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOpenCursorsAcrossRollback = function(callback) {\n  this._dbm.supportsOpenCursorsAcrossRollback(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports keeping statements open across\n * commits.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOpenStatementsAcrossCommit = function(callback) {\n  this._dbm.supportsOpenStatementsAcrossCommit(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports keeping statements open across\n * rollbacks.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOpenStatementsAcrossRollback = function(callback) {\n  this._dbm.supportsOpenStatementsAcrossRollback(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports using a column that is not in the\n * SELECT statement in an ORDER BY clause.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOrderByUnrelated = function(callback) {\n  this._dbm.supportsOrderByUnrelated(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports some form of outer join.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsOuterJoins = function(callback) {\n  this._dbm.supportsOuterJoins(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports positioned DELETE statements.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsPositionedDelete = function(callback) {\n  this._dbm.supportsPositionedDelete(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports positioned UPDATE statements.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsPositionedUpdate = function(callback) {\n  this._dbm.supportsPositionedUpdate(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the given concurrency type in\n * combination with the given result set type.\n *\n * @param {Number} type - Defined in java.sql.ResultSet\n * @param {Number} concurrency - Type defined in java.sql.ResultSet\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsResultSetConcurrency = function(type, concurrency, callback) {\n  var validParams = (\n    _.isInteger(type) &&\n    _.isInteger(concurrency)\n  );\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.supportsResultSetConcurrency(type, concurrency, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the given result set holdability.\n *\n * @param {Number} holdability - one of the following constants: ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so, false otherwise\n */\nDatabaseMetaData.prototype.supportsResultSetHoldability = function(holdability, callback) {\n  var validParams = _.isInteger(holdability);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.supportsResultSetHoldability(holdability, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the given result set type.\n *\n * @param {Number} type - defined in java.sql.ResultSet\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so, false otherwise\n */\nDatabaseMetaData.prototype.supportsResultSetType = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.supportsResultSetType(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports savepoints.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSavepoints = function(callback) {\n  this._dbm.supportsSavepoints(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a schema name can be used in a data manipulation\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSchemasInDataManipulation = function(callback) {\n  this._dbm.supportsSchemasInDataManipulation(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a schema name can be used in an index definition\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSchemasInIndexDefinitions = function(callback) {\n  this._dbm.supportsSchemasInIndexDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a schema name can be used in a privilege definition\n * statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSchemasInPrivilegeDefinitions = function(callback) {\n  this._dbm.supportsSchemasInPrivilegeDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a schema name can be used in a procedure call statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSchemasInProcedureCalls = function(callback) {\n  this._dbm.supportsSchemasInProcedureCalls(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether a schema name can be used in a table definition statement.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSchemasInTableDefinitions = function(callback) {\n  this._dbm.supportsSchemasInTableDefinitions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports SELECT FOR UPDATE statements.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSelectForUpdate = function(callback) {\n  this._dbm.supportsSelectForUpdate(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports statement pooling.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsStatementPooling = function(callback) {\n  this._dbm.supportsStatementPooling(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports invoking user-defined or vendor\n * functions using the stored procedure escape syntax.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsStoredFunctionsUsingCallSyntax = function(callback) {\n  this._dbm.supportsStoredFunctionsUsingCallSyntax(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports stored procedure calls that use the\n * stored procedure escape syntax.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsStoredProcedures = function(callback) {\n  this._dbm.supportsStoredProcedures(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports subqueries in comparison\n * expressions.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSubqueriesInComparisons = function(callback) {\n  this._dbm.supportsSubqueriesInComparisons(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports subqueries in EXISTS expressions.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSubqueriesInExists = function(callback) {\n  this._dbm.supportsSubqueriesInExists(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports subqueries in IN expressions.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSubqueriesInIns = function(callback) {\n  this._dbm.supportsSubqueriesInIns(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports subqueries in quantified\n * expressions.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsSubqueriesInQuantifieds = function(callback) {\n  this._dbm.supportsSubqueriesInQuantifieds(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports table correlation names.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsTableCorrelationNames = function(callback) {\n  this._dbm.supportsTableCorrelationNames(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports the given transaction isolation\n * level.\n *\n * @param {Number} level - one of the transaction isolation levels defined in java.sql.Connection\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so, false otherwise\n */\nDatabaseMetaData.prototype.supportsTransactionIsolationLevel = function(level, callback) {\n  var validParams = _.isInteger(level);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.supportsTransactionIsolationLevel(level, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports transactions.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsTransactions = function(callback) {\n  this._dbm.supportsTransactions(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports SQL UNION.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsUnion = function(callback) {\n  this._dbm.supportsUnion(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database supports SQL UNION ALL.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.supportsUnionAll = function(callback) {\n  this._dbm.supportsUnionAll(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether or not a visible row update can be detected by calling the\n * method ResultSet.rowUpdated.\n *\n * @param {Number} type - the ResultSet type; one of ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if changes are detected by the result set type; false otherwise\n */\nDatabaseMetaData.prototype.updatesAreDetected = function(type, callback) {\n  var validParams = _.isInteger(type);\n\n  if(! validParams) {\n    return callback(new Error('INVALID ARGUMENTS'));\n  }\n\n  this._dbm.updatesAreDetected(type, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database uses a file for each table.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.usesLocalFilePerTable = function(callback) {\n  this._dbm.usesLocalFilePerTable(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\n/**\n * Retrieves whether this database stores tables in a local file.\n *\n * @param {Function} callback\n * @returns {Boolean} Via callback: true if so; false otherwise\n */\nDatabaseMetaData.prototype.usesLocalFiles = function(callback) {\n  this._dbm.usesLocalFiles(function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, result);\n  });\n};\n\njinst.events.once('initialized', function onInitialized() {\n  // See https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html\n  // for full documentation for static attributes\n  var staticAttrs = [\n    'attributeNoNulls', 'attributeNullable', 'attributeNullableUnknown',\n    'bestRowNotPseudo', 'bestRowPseudo', 'bestRowSession', 'bestRowTemporary',\n    'bestRowTransaction', 'bestRowUnknown', 'columnNoNulls', 'columnNullable',\n    'columnNullableUnknown', 'functionColumnIn', 'functionColumnInOut',\n    'functionColumnOut', 'functionColumnResult', 'functionColumnUnknown',\n    'functionNoNulls', 'functionNoTable', 'functionNullable',\n    'functionNullableUnknown', 'functionResultUnknown', 'functionReturn',\n    'functionReturnsTable', 'importedKeyCascade',\n    'importedKeyInitiallyDeferred', 'importedKeyInitiallyImmediate',\n    'importedKeyNoAction', 'importedKeyNotDeferrable', 'importedKeyRestrict',\n    'importedKeySetDefault', 'importedKeySetNull', 'procedureColumnIn',\n    'procedureColumnInOut', 'procedureColumnOut', 'procedureColumnResult',\n    'procedureColumnReturn', 'procedureColumnUnknown', 'procedureNoNulls',\n    'procedureNoResult', 'procedureNullable', 'procedureNullableUnknown',\n    'procedureResultUnknown', 'procedureReturnsResult', 'sqlStateSQL',\n    'sqlStateSQL99', 'sqlStateXOpen', 'tableIndexClustered',\n    'tableIndexHashed', 'tableIndexOther', 'tableIndexStatistic', 'typeNoNulls',\n    'typeNullable', 'typeNullableUnknown', 'typePredBasic', 'typePredChar',\n    'typePredNone', 'typeSearchable', 'versionColumnNotPseudo',\n    'versionColumnPseudo', 'versionColumnUnknown',\n  ];\n\n  staticAttrs.forEach(function(attr) {\n    DatabaseMetaData[attr] = java.getStaticFieldValue('java.sql.DatabaseMetaData', attr);\n  });\n});\n\nmodule.exports = DatabaseMetaData;\n","/home/travis/build/npmtest/node-npmtest-jdbc/node_modules/jdbc/lib/sqlwarning.js":"/* jshint node: true */\n\"use strict\";\nfunction SQLWarning(sqlwarning) {\n  this._sqlwarning = sqlwarning;\n}\n\nmodule.exports = SQLWarning;\n"}